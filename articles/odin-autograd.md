---
title: "Odin で自動微分してみた感想"
emoji: "🙆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["自動微分", "odin"]
published: false
---

[Odin](https://odin-lang.org/) という言語があります。これは PC ゲーム向けではありますが、近頃流行っている C や C++ の代替となるネイティブコンパイル汎用言語です。 Rust ともポジションが近く気になっていたので、今回は自動微分シリーズに Odin を使いました。

https://github.com/msakuta/odigrad

自動微分シリーズはこれまでに [Rust](https://github.com/msakuta/rustograd), [Zig](https://github.com/msakuta/zigrad), [Scala](https://github.com/msakuta/scagrad), [Swift]() でやっています。

Odin の特徴は、低レイヤでありつつもモダンな言語機能を取り入れていることで、思想的には Zig が最も近いと思います[^1]。 Ginger Bill 氏の個人開発言語であり、 LLVM を使った多くの言語のうちの一つです[^2]。

[^1]: Jai にもかなり近いと思うのですが、 Jai はクローズドベータであり直接使うことはできないので、比較対象からは除外します。

[^2]: Ginger Bill 氏は LLVM をあまり好んでいないのですが、コンパイラの個人開発の敷居を下げるという意味では評価しており、 Odin にも「仕方がなく使った」という立ち位置のようです。将来的にはバックエンドは自前実装にしたいそうです。参照：https://www.youtube.com/watch?v=0mbrLxAT_QI&ab_channel=WookashPodcast

そのほか私の印象に残った特徴を挙げると次のようになります。

* 豊富なベンダーライブラリ(追加パッケージなしにゲームが作り始められる)
* 未定義動作は「定義する」ことによって排除する
* 暗黙に渡されるコンテキスト変数

## ベンダーライブラリ

Odin の最大の特徴かつ売りが、ベンダーライブラリです。これはコンパイラにバンドルされているライブラリ群で、 raylib や SDL などゲームのグラフィックスをサポートするのに役立つ多くのライブラリが含まれています。

その代わりと言ってはなんですが、 Odin にはパッケージマネージャがありません。自作のライブラリを配布する良い方法があるのかどうかわかりません。 Git のサブモジュールでも使うのでしょうか。

## 未定義動作はない

2番目の「未定義動作は「定義する」ことによって排除する」については少し説明が必要かと思います。

ネイティブコンパイル言語では未定義動作がよく問題になります。未定義動作にはさまざまありますが、よくあるのは未初期化のメモリを参照した時です。 C や C++ を始めとする最適化を施す言語では、未定義動作を引き起こした後に何が起きてもコンパイラの責任ではない、いわゆる「鼻から悪魔」という状態になります。 Rust では型システムによってこの未定義動作をコンパイル時に防いでいます。

Odin の (というよりも Ginger Bill 氏の思想の)中では、動作を定義してしまうことによって未定義動作を防ぐこととしています。たとえば、ヌルポインタを参照外しすればアクセス違反になり、整数がオーバーフローすればラップアラウンド (mod n) します。

これに関して私の感想は [#未定義動作に関する感想](#未定義動作に関する感想) に後述します。

## 導入方法

Odin の導入方法は驚くほど簡単です。 [Releases](https://www.youtube.com/watch?v=0mbrLxAT_QI&ab_channel=WookashPodcast) の中からプラットフォームごとのバイナリをダウンロードして展開し、 Odin 実行ファイルを実行するだけです。私は Windows で試しましたが、追加で必要になるパッケージなどはありませんでした。

## 未定義動作に関する感想

前述のとおり Odin は未定義動作に対してはかなりユニークなスタンスをとっていますが、このアプローチには一長一短あると思います。 Ginger Bill 氏は「最適化の結果は未定義動作にする必要はなく、定義できる」という思想を持っていますが、これには一理あるとは思いつつも全面的には賛同できません。

まず、最適化の方法は時代とともに変化するものです。最近の流れではメモリのアクセス時間がパフォーマンスのボトルネックになりがちなので、キャッシュメモリのヒット率を重視した最適化が重要になっています。また、最近の CPU に備わっている SIMD を活用するには、昔の CPU の最適化を下方互換を保ったままにすることはできません。 Odin は比較的新しい言語なので、そのような時代の変遷の試練を受けていないだけともいえます。 C や C++ がこれほどまでにも長寿なのは、コンパイラ側にも調整のゆとりを持たせる未定義動作があってこそといえるでしょう。

もう一つの問題は、 Odin が主要な CPU アーキテクチャ、 x86 と ARM しかサポートしていないことです。 C や C++ の時代は、様々な珍妙な CPU アーキテクチャが乱立しており、未定義動作なしには互換動作のために非常に高いコストを払うことになりかねませんでした。たとえば符号付き整数の負の数を表現するのに 1 の補数を使う CPU だった場合、 2 の補数でのラップアラウンドの動作を再現するには比較的込み入った計算をする必要があり、それもオーバーフローを起こしうるすべての演算 (加算、積算、減算)にコンパイラが導入することになります。このような場合は「符号付き整数のオーバーフローは未定義動作である」としてしまったほうが合理的でしょう。もちろん現代のコンピュータで符号付き整数に 2 の補数を使っていない CPU はほとんど存在しないでしょうが、「ほとんど存在しない」CPU をもサポートするのが C や C++ の価値だといえます。
